\section{Teilaufgabe C)}
\textbf{Versuchen Sie, die Laufzeit Ihres Programms zu beschleunigen! Dokumentieren Sie
einzelne Verbesserungsideen und die jeweiligen Laufzeitveränderungen für eine lokale
Ausführung Ihres Programms bei der Erzeugung einer 10-tps-Datenbank!}

\subsection{Transaktion}
Um den Durchsatz der Daten zu erhöhen, lassen sich die Queries in einer
\textbf{Transaktion}\footnote{\url{https://docs.oracle.com/javase/tutorial/jdbc/basics/transactions.html}} zusammenfassen.  

Dazu muss die Option \textit{autoCommit} abgeschaltet werden und die Transaktion
mit einem manuellen \textit{commit} zum Server geschickt werden. Wir mussten
also unseren \hyperref[lst:tpsv2]{TpsCreator} erweitern. In
dieser legen wir dazu 2 neue Funktionen an:

\begin{lstlisting}[caption={Erweiterung der TpsCreator-Klasse}]
	public void beginTransaktion() {
		try {
			connection.databaseLink.setAutoCommit(false);
		} catch (SQLException e) {
			e.printStackTrace();
		}
	}
	
	public void endAndCommitTransaction() {
		try {
			connection.databaseLink.commit();
			connection.databaseLink.setAutoCommit(true);
		} catch (SQLException e) {
			e.printStackTrace();
		}
	}
\end{lstlisting}

Jetzt brauchen wir noch die Funktionalität, um die Funktionen aufzurufen. Damit
wir recht flexibel sind haben wir hierfür ein Konsolen-Menü implementiert.
Dieses erstellt uns dann eine  \hyperref[lst:bmv2]{Benchmark}-Klasse, die der
\hyperref[lst:tpsv2]{TpsCreator}-Klasse alle nötigen Parameter übergibt und das Benchmarking ausführt.\\

\begin{lstlisting}[caption={Renderer für das Konsolen Menü}]
	public static int renderMenu() {
		System.out.println("======================- Benchmark Menu -===========================");
		System.out.println("= Wähle bitte eine der folgende Optionen:                         =");
		System.out.println("= (1) Benchmark, Debug Log, incl. drop & create                   =");
		System.out.println("= (2) Benchmark, Debug Log, excl. drop & create                   =");
		System.out.println("= (3) Benchmark, Debug Log, transactions, incl. drop & create     =");
		System.out.println("= (4) Benchmark, Debug Log, transactions, excl. drop & create     =");
		System.out.println("= (5) Benchmark, incl. drop & create                              =");
		System.out.println("= (6) Benchmark, excl. drop & create                              =");
		System.out.println("= (7) Benchmark, transactions, incl. drop & create                =");
		System.out.println("= (8) Benchmark, transactions, excl. drop & create                =");
		System.out.println("===================================================================");
		System.out.print("= Auswahl: ");
		
		return ConsoleReader.readInt();
	}
\end{lstlisting}

 
Die Queries, die mittels einer Transaktion übertragen worden sind, sind bei
einer \textbf{10-tps-Datenbank} um \ca das \textbf{11fache} schneller als die

Queries die einzelnd zum Server geschickt werden.

\subsection{Schlüsselbedingungen}
In den create-Statements befinden sich Schlüsselbedingungen für die Primär- und
Fremdschlüssel. Jeder Schlüssel erstellt auch einen sgn. Index. Beim Einfügen
der Daten in die jeweiligen Tabellen ist so ein Index hinderlich, da anhand
dieser einige Bedingungen geprüft werden und somit wertvolle Sekunden im
Benchmarking kostet.

Entkapselt man also diese und fügt diese erst am Ende des Benchmark-Vorgangs
an, so braucht der Server diese Bedingungen nicht zu überprüfen. Wir müssen uns
also eine Funktion schreiben, die Ende jedes Benchmarks ausgeführt wird.

\begin{lstlisting}[caption={Alter Statements \& Funktion createKeys}]
	/**
	 * Alter Statements zum setzen der Keys
	 */
	
	public String[] AlterStatements = {
			"ALTER TABLE branches ADD PRIMARY KEY(branchid)",
			"ALTER TABLE accounts ADD PRIMARY KEY(accid)",
			"ALTER TABLE tellers ADD PRIMARY KEY(tellerid)",
			"ALTER TABLE accounts ADD  FOREIGN KEY(branchid) REFERENCES branches(branchid)",
			"ALTER TABLE tellers ADD  FOREIGN KEY(branchid) REFERENCES branches(branchid)",
			"ALTER TABLE history ADD  FOREIGN KEY(branchid) REFERENCES branches(branchid)",
			"ALTER TABLE history ADD  FOREIGN KEY(tellerid) REFERENCES tellers(tellerid)",
			"ALTER TABLE history ADD  FOREIGN KEY(accid) REFERENCES accounts(accid)"
	};
	
	/**
	 * Erstellt die Schlüasselbedingungen
	 * 
	 * @return Gibt an, ob win Fehler vorhanden ist.
	 */
	public boolean createKeys() {
	
		try {
			Statement statement = connection.databaseLink.createStatement();

			for (String table : this.AlterStatements) {
				statement.executeUpdate(table);
				if(isDebug) {
					System.out.println(table);
				}
			}

			return true;
		} catch (SQLException e) {
			System.out.println(e.getMessage());
			return false;
		}
	}
		
\end{lstlisting}

Durch diese Funktion ist es jetzt möglich die Schlüsselfunktionen entkapselt von
der Tabellen Definition anzulegen.


\subsection{Implementierung des CopyManagers}
Unser ausgewähltes DBMS PostgreSQL stellt ein \textbf{COPY}-Statement zur
Verfügung. Dieses Statement erlaubt uns Daten aus einer Textdatei oder aber auch
einer CSV Datei in unsere Datenbank zu importieren. 

Das \textbf{COPY}-Stament ist durch seine starke Spezialisierung auf den
Anwendungszwecks um einiges schneller als die ansich schon schnelle
PreparedStatements.

Um dieses Feature zu nutzen, stellt uns der JDBC-Treiber von PostgreSQL eine
\textbf{CopyManager}\footnote{\url{https://jdbc.postgresql.org/documentation/publicapi/org/postgresql/copy/CopyManager.html}}-Klasse
zur Verfügung. Diesen Manager übergeben wir lediglich ein
\textbf{COPY}-Statement.

\begin{lstlisting}[caption={Instantiierung des CopyManagers}]
CopyManager cpm = new CopyManager((BaseConnection) connection.databaseLink);
CopyIn ci = cpm.copyIn("COPY branches (branchid, branchname, balance, address) FROM STDIN WITH DELIMITER '|'");
\end{lstlisting}

Mit dem dadurch erzeugtem \textbf{CopyIn}-Objekt sind wir jetzt dazu in der Lage
Daten dem CopyManager zu übergeben. Das machen wir mittels der
\textbf{writeToCopy}-Funktion:

\begin{lstlisting}[caption={WriteToCopy-Funktion}]
ci.writeToCopy(sb.toString().getBytes(), 0, sb.length());
\end{lstlisting}

Sind wir mit dem \textbf{COPY}-Vorgang fertig, müssen nur noch die Funktion
\textbf{endCopy} um die Daten zum Server zu übertragen.

Wenn wir also die create-Funktionen in der Klasse
\hyperref[lst:tpsv2]{TpsCreator} abändern erhalten wir folgenden Code:

\begin{lstlisting}[caption={createAccountTupel mit CopyManager}]
	/**
	 * Erstellt die Tupel in der Tabelle Accounts
	 * 
	 * @param n Anzahl der Tupel, die erstellt werden mal 10000
	 * @return Gibt an, ob ein Fehler vorhanden ist
	 */
	public boolean createAccountTupel(int n) {
		int localConst = n*10000;
		try {
			CopyManager cpm = new CopyManager((BaseConnection) connection.databaseLink);
			
			CopyIn ci = cpm.copyIn("COPY accounts(accid, NAME, balance, address, branchid) FROM STDIN WITH DELIMITER '|'");

			for (int i = 1; i <= localConst; i++) {
				/* Stringbuilder immer neu erstellen, denn je größer dieser wird, desto langsamer wird dieser auchD
				* Der Initialwert des Stringbuilders ist extrem wichtig, denn durch diesen Wert wird automatisch genug Speicher reserviert
				*/
				StringBuilder sb = new StringBuilder("|aaaaaaaaaaaaaaaaaaaa|0|aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa|").append(
						ThreadLocalRandom.current().nextInt(1, n + 1)
				).append("\n").insert(0, i);
				
				ci.writeToCopy(sb.toString().getBytes(), 0, sb.length());
				
				if(isDebug) {
					System.out.print(sb.toString());
				}
			}
	        ci.endCopy();			
			return true;
		} catch (SQLException e) {
			e.printStackTrace();
		}
		
		return false;
	}
\end{lstlisting}

Da wir mit der Variante viel mit Strings arbeiten, hat es sich angeboten einen
StringBuilder anstatt der üblichen Verkettung zu nehmen, da der StringBuilder
wesentlich performanter läuft als die Verkettung von Datentypen.

Diese Art des Einfügen in die Datenbank erlaubt uns bei einer
\textbf{50-tps-Datenbank} ein Benchmarkergebnis von 2500 Millisekunden.

Selbst Größen jenseits $n > 50$ laufen binnen weniger Sekunden problemlos durch.

\subsection{Servereinstellungen}

Um ein noch besseres Eregbnis zu erzielen kann man in PostgreSQL die
\textit{asyncronen Commits} aktivieren. Diese sind Stanardmäßig dieaktiviert und
müssen in der Konfigurationsdatei von PostgreSQL ersteinmal aktiviert
werden\footnote{\url{https://www.postgresql.org/docs/current/static/wal-async-commit.html}}.

Unter Unix-Systemen liegt die Konfigurationsdatei meistens unter \newline
\gqq{\textit{/etc/postgresql/\{versionsnummer\}/main/postgresql.conf}}

Aktivierte \& geänderte Serverkonfiguration:
\begin{lstlisting}[title={Veränderte Serverkonfiguration}]
shared_buffers		= 1GB

#wal-writer Engine
synchronous_commit	= off
wal_writer_delay	= 5000ms
commit_delay		= 50000
wal_buffers			= 128MB
\end{lstlisting}

\textbf{shared\_buffer} beschreibt, wie viel Ram der Server belegen darf.
Standardmäßig steht dieser Wert auf 128MB. Stellt man diesen Wert hoch erhöht
sich der Durchsatz der Daten maginal. Ein guter Wert ist immer $1/4$ des
Server-Rams. In unaseren  Fall ist das dementsprechend 1GB.

Die \gqq{wal-writer}-Engine ist dafür verantwortlich, wie die Daten auf die
Festplatte weggeschrieben werden.

Der Performanceschub fällt je nach System unterschiedlich aus.So hat diese
Konfiguration auf den Laptop eines Kommilitonen eine Einsparung von 100
Millisekunden bei einer \textbf{10-tps-Datenbank} eingebracht.

\subsection{Adressauflösung von Domainnamen}
Um das Ergebnis noch mehr zu verbessern kommt nun das Feintuning. Dazu
haben wir uns jetzt nicht das DBMS zugewendet, sondern haben uns auf die
Netzwerkebene begeben.

Eine Datenbank spricht man normalerweiße mit einer Domain an. 
Eine Domain muss aber erst einmal aufgelöst werden.
Das ist ein massiver Nachteil gegenüber der herkömmlicher IP. Jeder
DNS-Server \bzw DNS-Cache muss in irgendeiner Tabelle nachschauen, welche Domain
zu welcher IP gehört. Das kostet beim Verbindungsaufbau wertvolle Zeit.

Selbst der lokale DNS-Cache muss dies \zB für \textbf{localhost} machen.
Möchten wir also die Zugriffszeiten umgehen, brauchen wir einfach nur die IP-Adresse
statt des Domainnamens einzugeben. Dies wäre für \textbf{localhost} entweder \gqq{127.0.0.1} als
IPv4-Schreibweiße oder \gqq{[::1]} als IPv6 Schreibweise.

Wir haben in unser Programm deswegen nur IP-Adressen verwendet um sicher zu gehen, dass wir 
die Zugriffszeiten umgegehen. Einen Performanceschub im
Benchmark bringt diese Optimierung nicht wirklich.

\subsection{Gesamter Performancezuwachs}
Durch das Schrittweiße optimieren des Programmcodes konnte ein betrachtlicher
Performancezuwachs erzielt werden. Zwar ist es in der Praxis nicht immer möglich
jede der hier aufgeführten Optimierungen zu nutzen, doch es zeigt, was möglich
ist, wenn man sich mit den jeweiligen Datenbanken und Datenbanktreibern beschäftigt.

Die folgende Tabelle zeigt den Performancezuwachs prozentual zur unoptimierten
Programmversion an einer \textbf{10-tps-Datenbank}: 


\tabelle{Leistungszuwachs
durch Optimierungen}{tab:Zuwachs}{Zuwachs.tex}

\clearpage